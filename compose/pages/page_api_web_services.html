<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Layouts in Compose</title>
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">
</head>

<body>
<header>
    <h1 class="header-heading">Jetpack Compose / API Web-Services</h1>
    <div>
        <a class="menu" href="../todo.html" id="todoLink">To-Do</a>
        <a class="menu" href="../notes.html" id="notesLink">Notes</a>
        <a class="menu selected" href="../../index.html" id="composeLink">Compose</a>
        <a class="menu" href="../../profile/index.html" id="profileLink">Profile</a>
    </div>
</header>

<div class="page">
    <div class="code-container"></div>

    <div class="list">
        <div class="item-container">

            <div class="page-card def-selected" card-id="1">
                <h2>Notes</h2>
                <p>Few Notes related to API &amp; Webservices</p>
            </div>


            <div class="page-card def-selected" card-id="2">
                <h2>Basic API Call</h2>
                <p>Basic code for API call in compose, (ref. codelab)</p>
            </div>

            <div class="page-card def-selected" card-id="3">
                <h2>Dependency Injection</h2>
                <p>DI Pattern in Compose</p>
            </div>

        </div>
    </div>
</div>




<script type="text/javascript">

    const profileLink = document.getElementById("profileLink");
    const composeLink = document.getElementById("composeLink");
    const headerHeading = document.querySelector(".header-heading");

    profileLink.addEventListener("click", () => {
        profileLink.classList.add("selected");
        composeLink.classList.remove("selected");
        headerHeading.textContent = "Akshay's Profile";
    });

    composeLink.addEventListener("click", () => {
        composeLink.classList.add("selected");
        profileLink.classList.remove("selected");
        headerHeading.textContent = "Jetpack Compose";
    });

    //---------------------------------------------------------------
    const cards = document.querySelectorAll('.page-card');
    const dataContainer = document.querySelector('.code-container');
    cards.forEach(pcard => {
        pcard.addEventListener('click', () => {
            cards.forEach(otherCard => {
                otherCard.classList.remove('selected-card');
            });
            pcard.classList.add('selected-card');
        });
    });

    const defaultSelectedCard = document.querySelector('.def-selected');
    if (defaultSelectedCard) {
        defaultSelectedCard.classList.add('selected-card');
        const cardId = defaultSelectedCard.getAttribute('card-id');
        const data = fetchDataById(cardId);
        displayData(data);
    }

    cards.forEach(card => {
        card.addEventListener('click', () => {
            const cardId = card.getAttribute('card-id');
            const data = fetchDataById(cardId);
            displayData(data);
        });
    });

    function fetchDataById(cardId) {
        console.log(`Fetching data for card ID: ${cardId}`);

        const data = [
            { id: 1, src: 'image_url', description: `
Retrofit Dependency:
implementation("com.squareup.retrofit2:retrofit:2.9.0")
// Retrofit with Kotlin serialization Converter
implementation("com.jakewharton.retrofit:retrofit2-kotlinx-serialization-converter:1.0.0")
implementation("com.squareup.okhttp3:okhttp:4.11.0")


VVV-IMP:
In Compose also ViewModel is Responsible to get data from server,
It saves data in mutableState of variable, so whenever data changes
Compose will get reCompose

Add kotlinx.serialization library dependencies
1. build.gradle.kts (Module :app) & (Module :Project)
2. Add Plugin -> id("org.jetbrains.kotlin.plugin.serialization") version "1.8.10"
3. Add Dependency -> implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.5.1")
4. Sync

----------------------------------------------------------------------------
Note:
In App threre is 3 ways to get data
1. From Local Storage (Room or Preference)
2. From Network Call
3. From File

Repository is Responsible for get the data based on condition
that's why 1 interface is define to override same method in all 3 classes
Ex.


interface CommonMethodInterface {
    fun getData(): String
}

class DataFromNetworkApiCall: CommonMethodInterface {
    override fun getData(): String {
        return "Take this data from API Call"
    }
}
class DataFromRoomDatabase(): CommonMethodInterface {
    override fun getData(): String {
        return "Take this Data from Room DB or Share Pref"
    }
}
class DataFromFile(): CommonMethodInterface {
    override fun getData(): String {
        return "Take this data from File in device"
    }
}
class DataFromThirdParty(): CommonMethodInterface {
    override fun getData(): String {
        return "Take this data from any third party"
    }
}
class DataFromFirebase(): CommonMethodInterface {
    override fun getData(): String {
        return "Take this data from Firebase"
    }
}


As you can see single interface is implemented to all different Classes
This Mean based on situation data can get from anywhere without affecting of other
classes
From ViewModel you just call getData() function, this function is same in all class
Hence you don't have an headache for, from where data should take
Repository handle this for you, you just need to call a function


            `
            },

            { id: 2, src: 'image_url', description: `
ApiServices.kt

private const val BASE_URL = "https://android-kotlin-fun-mars-server.appspot.com"

private val retrofit = Retrofit.Builder()
    .addConverterFactory(Json.asConverterFactory("application/json".toMediaType()))
    .baseUrl(BASE_URL)
    .build()


interface MarsApiService {

    @GET("photos")
    suspend fun getPhotos(): List&lt;MarsPhoto&gt;
}

object MarsApi {
    val retrofitService : MarsApiService by lazy {
        retrofit.create(MarsApiService::class.java)
    }
}
--------------------------------------------------------------------------------------
@Serializable
data class MarsPhoto (
    val id: String,
    @SerialName(value = "img_src")
    val imageUrl: String
)
--------------------------------------------------------------------------------------
ViewModel
val viewModel: ViewModelName = viewModel()

sealed interface MarsUiState {
    data class Success(val data : String) :MarsUiState
    object Error: MarsUiState
    object Loading:MarsUiState
}

class MarsViewModel : ViewModel() {
    var marsUiState: MarsUiState by mutableStateOf(MarsUiState.Loading)
        private set

    init { getMarsPhotos() }

    fun getMarsPhotos() {
        viewModelScope.launch(Dispatchers.IO) {
            marsUiState = try {
                val list = MarsApi.retrofitService.getPhotos()
                MarsUiState.Success("&#36;{list.size} photos are received")
            }catch (ex: IOException) {
                MarsUiState.Error
            }
        }
    }
}
---------------
Please Take a Note about Plugin for API call for Serialization
            `
            },
            { id: 3, src: 'https://raw.githubusercontent.com/pwraxe/compose/main/compose/images/di_pattern_flow.png', description: `

Application Class
=================
class MarsPhotosApplication: Application() {

    lateinit var container: AppContainer
    override fun onCreate() {
        super.onCreate()
        container = DefaultAppContainer()
    }
}
_________________________________________________________________________________
ViewModel
=========

class MarsViewModel(private val marsPhotosRepository: MarsPhotosRepository) : ViewModel() {

    var marsUiState: MarsUiState by mutableStateOf(MarsUiState.Loading)
        private set

    init { getMarsPhotos() }

    fun getMarsPhotos() {
        viewModelScope.launch {
            marsUiState = MarsUiState.Loading
            marsUiState = try {
                val listResult = marsPhotosRepository.getMarsPhoto()
                MarsUiState.Success(
                    "Success: &#36;{listResult.size} Mars photos retrieved"
                )
            } catch (e: IOException) {
                MarsUiState.Error
            } catch (e: HttpException) {
                MarsUiState.Error
            }
        }
    }

    companion object {
        val Factory : ViewModelProvider.Factory = viewModelFactory {
            initializer {
                val application = (this[APPLICATION_KEY] as MarsPhotosApplication)
                val marsPhotoRepository = application.container.marsPhotosRepository
                MarsViewModel(marsPhotosRepository = marsPhotoRepository)
            }
        }
    }
}
_________________________________________________________________________________
Single interface implemented at multiple class to get data from different sources

interface MarsPhotosRepository {
    suspend fun getMarsPhoto(): List<MarsPhoto>
}
class NetworkMarsPhotoRepository(private val marsApiService: MarsApiService): MarsPhotosRepository {
    override suspend fun getMarsPhoto(): List<MarsPhoto> {
        return marsApiService.getPhotos()
    }
}
_________________________________________________________________________________
interface MarsApiService {
    @GET("photos")
    suspend fun getPhotos(): List<MarsPhoto>
}
_________________________________________________________________________________
interface AppContainer {
    //This variable for creating object of class which implement from interface for get data
    val marsPhotosRepository: MarsPhotosRepository
}

class DefaultAppContainer: AppContainer {

    private val BASE_URL = "https://android-kotlin-fun-mars-server.appspot.com"

    private val retrofit = Retrofit.Builder()
        .addConverterFactory(Json.asConverterFactory("application/json".toMediaType()))
        .baseUrl(BASE_URL)
        .build()

    private val retrofitService: MarsApiService by lazy {
        retrofit.create(MarsApiService::class.java)
    }

    //From Network API
    override val marsPhotosRepository: MarsPhotosRepository by lazy {
        NetworkMarsPhotoRepository(retrofitService)
    }

    //Add More Variable for get data
}
_________________________________________________________________________________
Model Class Or POJO class

@Serializable
data class MarsPhoto(
    val id: String,
    @SerialName(value = "img_src")
    val imgSrc: String
)
_________________________________________________________________________________
This is how you create Object for ViewModel if ViewModel takes a data in constructor
val marsViewModel: MarsViewModel = viewModel(factory = MarsViewModel.Factory)


            `

            }
        ];

        return data.find(item => item.id === parseInt(cardId));
    }

    function displayData(data) {
        console.log(`Displaying data: ${data}`);
        if (data) {
            dataContainer.innerHTML = `

                     <div class="output-image">
                    <img src="${data.src}" alt="Output 1" width="100%" height="100%">
                </div>

                <div class="output-code">

                    <pre>
                        <code class="language-kotlin">${data.description}</code>
                    </pre>
                </div>
            `;
        } else {
            dataContainer.innerHTML = 'Data not found';
        }
    }
</script>

</body>
</html>
